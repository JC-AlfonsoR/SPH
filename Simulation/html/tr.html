
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>tr</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-18"><meta name="DC.source" content="tr.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Jc_tensile</a></li><li><a href="#2">Constantes</a></li><li><a href="#3">Definir Geoemtr&#65533;a</a></li></ul></div><h2>Jc_tensile<a name="1"></a></h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Este script consiste en una copia de el escript tensileroadsph.m autoria de
</span><span class="comment">ing. Daniel Luna.
</span><span class="comment">Desarrollo este script para entender la estructura general del c&#65533;digo de
</span><span class="comment">referencia.
</span><span class="comment">%}
</span>clear <span class="string">all</span>;clc;
</pre><pre class="codeoutput">Error: File: /usuarios/homenfs1/jc.alfonso2004/Documents/GitHub/Ad_Remotis/Carpentry/tr.m Line: 76 Column: 7
Expression or statement is incorrect--possibly unbalanced (, {, or [.
</pre><h2>Constantes<a name="2"></a></h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Todas las unidades en sistema internacional de unidades
</span><span class="comment">%}
</span>dy = 0.000384848;   <span class="comment">%   [1x1] separacion entre particulas-</span>
dx = dy;            <span class="comment">%-</span>
hdx = 2.0;          <span class="comment">%   [#] cte para expandir radio-</span>
h = hdx*dx;         <span class="comment">%   [#] Radio para dominio soporte-</span>

r0 = 7850;          <span class="comment">%   [#] densidad volumetrica del acero</span>
m0 = dx*dy*r0;      <span class="comment">%   [#] masa de una particula. (dz=1)</span>
v_s = 300;          <span class="comment">%   [#] velocidad incial</span>

    ss = 4699;      <span class="comment">%   [#]  ---</span>
    C = 3630;       <span class="comment">%   [#] Huggoniot</span>
    S = 1800;       <span class="comment">%   [#]  ---</span>

    gamma = 1.81;   <span class="comment">%   [#]  ---</span>
    alpha = 0.5;    <span class="comment">%   [#]</span>
    beta = 0.5;     <span class="comment">%   [#] XSPH</span>
    eta = 0.01;     <span class="comment">%   [#]</span>
    eps = 0.5;      <span class="comment">%   [#]  ---</span>

bar_width = 0.0076; <span class="comment">%   [#] Ancho de la barra-</span>
G = 8*10^10;        <span class="comment">%   [#] Modulo Cortante</span>
Yo = 6*10^8;        <span class="comment">%   [#] Esfuerzo de fluencia</span>
E = ss^2*r0;        <span class="comment">%   [#] Modulo de Young - calculado con parametros</span>
                    <span class="comment">%        de Huggoniot</span>
ro2 = 2750;         <span class="comment">%   [#] Densidad aluminio ~ creo que es la densidad</span>
                    <span class="comment">%        del proyectil</span>
platestart = -2*bar_width; <span class="comment">%[#] Dominio 2D debe empezar en esta posici&#65533;n</span>
plateend = 2*bar_width;    <span class="comment">%[#] Dominio 2D debe terminar en esta posici&#65533;n</span>

    m = 3;          <span class="comment">%   [#] parametros de Weibull para generacion de</span>
    k = 7;          <span class="comment">%   [#] fractuas al interior del material</span>

V = dx*dy;          <span class="comment">%   [#] Volumen infinitesimal</span>
dt = 1*10^-7;       <span class="comment">%   [#] Paso de tiempo</span>
tf = 1e-6*20;       <span class="comment">%   [#] Tiempo final</span>
</pre><h2>Definir Geoemtr&#65533;a<a name="3"></a></h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">En esta secci&#65533;n se crean las posiciones de las particulas y se asginan las
</span><span class="comment">fallas.
</span><span class="comment">%}
</span>xbar = -bar_width/2:dx:bar_width/2+dx;  <span class="comment">% [#:dx:#] posiciones en x-</span>
ybar = 0:dy:0.0254;         <span class="comment">%   [#:dy:#]    posiciones en y-</span>
[X,Y] = meshgrid(xbar,ybar);<span class="comment">%   [Matriz]    Matrices que con la malla -</span>
                            <span class="comment">%       de las posiciones para las particulas-</span>

coorbar = [X(:),Y(:)];      <span class="comment">%   | x_1 , y_1 |   En esta matriz organiza   -</span>
                            <span class="comment">%   | .   , .   |   todas las posiciones de las</span>
                            <span class="comment">%   | x_n , y_n |   particulas. -</span>
                            <span class="comment">%   [npart x 2] -</span>

numrpart = length(X(:));    <span class="comment">%   [#] Numero de particulas. ~size(1,coorbar) -</span>
Nflaws = numrpart*log(numrpart);<span class="comment">%[#] Numero de fallas en el material-</span>
Nflaws = round(Nflaws);         <span class="comment">% ~Modelo de fallas-</span>
Flawpart = randi(numrpart,Nflaws,1,<span class="string">'uint32'</span>); <span class="comment">%[Nflaws x 1]</span>
                            <span class="comment">%   vector que contiene # aleatorio entre 1 y</span>
                            <span class="comment">%   numpart para cada una de las Nflaws</span>
coorglobal = coorbar;       <span class="comment">%   [Matriz] copia de la matriz coorbar</span>
numpart = numrpart;         <span class="comment">%   [#] copia de numero de particulas</span>

[Flaws{1:numrpart,1}] = deal(zeros(0)); <span class="comment">% Flaws [cell array] {numrpart x 1}</span>
                            <span class="comment">%   Cell array con 'numrpart' matrices vacias</span>
                            <span class="comment">%   Cell de prealocaci&#65533;n para fallas</span>
randi(
<span class="keyword">for</span> i = 1:length(Flawpart)
    Flaws{Flawpart(i),1}(size(Flaws{Flawpart(i),1})+1) = (i/(k*V))^(1/m);
<span class="keyword">end</span>
<span class="comment">% Flawpart  [Nflaws x 1]     vector que contiene Nflaws posiciones de las</span>
<span class="comment">% fallas a generar. Las posiciones estan dadas como numeros enteros en</span>
<span class="comment">% relaci&#65533;n al n&#65533;mero de cada part&#65533;cula.</span>
<span class="comment">% Flaws     cell{numrpart x 1}  contiene 'numrpart' matrices vacias que</span>
<span class="comment">% identifican las fallas para cada particula.</span>
<span class="comment">% Flaws se va llenando con las posciones que indica Flawpart. La primera</span>
<span class="comment">% vez que pasa por una matriz de Flaws, le imprime el n&#65533;mero</span>
<span class="comment">% entero (i/(k*v))^(1/m) formando una matriz 1x1. La segunda vez que pasa</span>
<span class="comment">% por la misma matriz, aumenta la dimension de la matriz en una sola</span>
<span class="comment">% direccion para imprimir otro n&#65533;mero entero. As&#65533;, si semialeatoriamente,</span>
<span class="comment">% el numero 'k' aparecio 'n' veces en Flawpart, la celda Flaws en su</span>
<span class="comment">% posicion 'k' debe contener una matriz nx1 de n&#65533;mero enteros.</span>
<span class="comment">%{
</span><span class="comment">%% Otras Matrices
</span><span class="comment">% ~Luna no espececifica comentarios para estas matrices
</span><span class="comment">M = (ones(numpart,1))*dx*dy*r0; %[numpart x 1] Masa de las particulas
</span><span class="comment">Rho = (ones(numpart,1))*r0;     %[numpart x 1] Densidad de las particulas
</span><span class="comment">drho = zeros(numpart,1);        %[numpart x 1] Derivada de la densidad
</span><span class="comment">D = zeros(numpart,1);           %[numpart x 1] Da&#65533;o de cada part&#65533;cula [0 1]
</span><span class="comment">cs = ss*ones(numpart,1);        %[numpart x 1] ~Velocidad del sonido
</span><span class="comment">
</span><span class="comment">%% Velocidades
</span><span class="comment">V1 = zeros(numpart,1);          %[numpart x 1] Velocidad 1 -&gt; 0's
</span><span class="comment">V2 = ones(numpart,1);           %[numpart x 1] Velocidad 2 -&gt; 1&#65533;s
</span><span class="comment">
</span><span class="comment">Vdistr = linspace(-v_s,v_s,67); %[1 x 67] Distribucion de velocidad
</span><span class="comment">                                % vector fila, espacio discretizado en 67
</span><span class="comment">                                % puntos desde -v_s hasta v_s
</span><span class="comment">for i=1:(numrpart/67)
</span><span class="comment">    V2((i-1)*67+1:i*67) = Vdistr';
</span><span class="comment">end
</span><span class="comment">% El recorrido se realiza numpart/67 = 1407/67 = 21 veces. En cada uno de
</span><span class="comment">% los recorridos, Vdistr se convierte a columna y se guarda en V2. As&#65533;,
</span><span class="comment">% Vdistr se repite 21 veces dentro de V2. Creo que el #67 se debe a la
</span><span class="comment">% forma en la que esta creada la malla, indicando que la distribuci&#65533;n de
</span><span class="comment">% velocidad se realiza sobre 67 particulas en fila.
</span><span class="comment">
</span><span class="comment">Velplot = zeros(size(X));       % [Matriz] Matriz para graficar. Tiene el
</span><span class="comment">                                %   mismo tama&#65533;o que la matriz de malla X.
</span><span class="comment">for i=1:numpart
</span><span class="comment">   Velplot(i) = V2(i);
</span><span class="comment">end
</span><span class="comment">% La matriz Velplot se llena con los datos del vector V2. De esta forma,
</span><span class="comment">% Velplot queda con 21 columnas de 67 filas. Cada Columna conteniendo el
</span><span class="comment">% vector Vdistr
</span><span class="comment">
</span><span class="comment">%image([-100 100], [-100 100], Velplot, 'CDataMapping', 'scaled');
</span><span class="comment">%xlabel('X (normalizado a 100)'); ylabel('Y (normalizado a 100)');colorbar;
</span><span class="comment">% Grafica Velplot como una im&#65533;gen. En x se presentan 21 puntos y en y se
</span><span class="comment">% presentan 67 puntos. La velocidad no cambia con x.
</span><span class="comment">
</span><span class="comment">%% Derivadas
</span><span class="comment">%{
</span><span class="comment">Aca se inicializan las matrices de todas las derivadas
</span><span class="comment">%}
</span><span class="comment">
</span><span class="comment">% Aceleracion
</span><span class="comment">dV1 = zeros(numpart,1);     %[numpart x 1] Derivada total de V1
</span><span class="comment">dV2 = zeros(numpart,1);     %[numpart x 1] Derivada total de V2
</span><span class="comment">    % Derivadas Espaciales
</span><span class="comment">    dv1dx1 = zeros(numpart,1);  %[numpart x 1] Derivada V1 en dir 1 (x)
</span><span class="comment">    dv1dx2 = zeros(numpart,1);  %[numpart x 1] Derivada V1 en dir 2 (y)
</span><span class="comment">    dv2dx1 = zeros(numpart,1);  %[numpart x 1] Derivada V2 en dir 1 (x)
</span><span class="comment">    dv2dx2 = zeros(numpart,1);  %[numpart x 1] Derivada V2 en dir 2 (y)
</span><span class="comment">
</span><span class="comment">P = zeros(numpart,1);       %[numpart x 1] Presion Hidrostatica
</span><span class="comment">
</span><span class="comment">% Esfuerzos
</span><span class="comment">dev11 = zeros(numpart,1);   % -----------
</span><span class="comment">dev12 = zeros(numpart,1);   % Esfuerzos Cortantes
</span><span class="comment">dev21 = zeros(numpart,1);   % [numpart x1]
</span><span class="comment">dev22 = zeros(numpart,1);   % ------------
</span><span class="comment">    % Derivadas Espaciales
</span><span class="comment">    ddev11 = zeros(numpart,1);  %------------
</span><span class="comment">    ddev12 = zeros(numpart,1);  % Derivadas Espaciales de los esfuerzos
</span><span class="comment">    ddev21 = zeros(numpart,1);  % [numpart x 1]
</span><span class="comment">    ddev22 = zeros(numpart,1);  %------------
</span><span class="comment">
</span><span class="comment">% Deformaciones
</span><span class="comment">eps11 = zeros(numpart,1);   %------------
</span><span class="comment">eps12 = zeros(numpart,1);   % Deformacion Unitaria
</span><span class="comment">eps21 = zeros(numpart,1);   %   [numpart x 1]
</span><span class="comment">eps22 = zeros(numpart,1);   %------------
</span><span class="comment">
</span><span class="comment">eint = zeros(numpart,1);    % Energ&#65533;a interna y derivada
</span><span class="comment">deint = zeros(numpart,1);   %   [numpart x 1]
</span><span class="comment">%% Incio de la simulaci&#65533;n
</span><span class="comment">%{
</span><span class="comment">Aca se corre la simulaci&#65533;nn
</span><span class="comment">%}
</span><span class="comment">display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
</span><span class="comment">display('   Inicio de la Simulaci&#65533;n   ');
</span><span class="comment">display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
</span><span class="comment">
</span><span class="comment">t = 0;              %   int     Tiempo inicial
</span><span class="comment">steps = tf/dt;      %   int     Numero de pasos
</span><span class="comment">
</span><span class="comment">% Matrices para guardar informaci&#65533;n de la simulaci&#65533;n.
</span><span class="comment">Coordenadas = zeros([size(coorbar), steps]);
</span><span class="comment">Velocidad1 = zeros([size(V1),steps]);
</span><span class="comment">Velocidad2 = zeros([size(V2),steps]);
</span><span class="comment">Presion = zeros([size(P),steps]);
</span><span class="comment">Esfuerzos11 = zeros([size(dev11), steps]);
</span><span class="comment">Esfuerzos12 = zeros([size(dev12), steps]);
</span><span class="comment">Esfuerzos21 = zeros([size(dev21), steps]);
</span><span class="comment">Esfuerzos22 = zeros([size(dev22), steps]);
</span><span class="comment">Densidad = zeros([size(Rho), steps]);
</span><span class="comment">
</span><span class="comment">for ti=1:steps
</span><span class="comment">%%
</span><span class="comment">    fprintf('P %d/%d \n',ti,steps);
</span><span class="comment">    %~~~~~ Inicializaci&#65533;n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="comment">    [Nearpart,Dist] = rangesearch(coorbar,coorbar,h);
</span><span class="comment">    %   Nearpart    cell {npart x 1}
</span><span class="comment">    %   En el compartimiento i de Nearpart, se encuentra un vector [1 x n]
</span><span class="comment">    %   que contiene los indices de las n particulas vecinas a la part&#65533;cula
</span><span class="comment">    %   de identidad i.
</span><span class="comment">    %   Dist        cell {npart x 1}
</span><span class="comment">    %   En el compartimiento i de Dist, se encuentra un vector [1 x n] que
</span><span class="comment">    %   contiene la distancia r_n a la que se encuentra cada una de las n
</span><span class="comment">    %   particulas vecinas de la part&#65533;cula i.
</span><span class="comment">
</span><span class="comment">    kern = Dist;    %   cell {npart x 1}    kern contiene npart vectores,
</span><span class="comment">                        % uno para cada particula. Cada vector mide [1x ni]
</span><span class="comment">                        % siendo ni el numero de particulas vecinas de la
</span><span class="comment">                        % particula i
</span><span class="comment">
</span><span class="comment">    kern = cellfun(@(x) x*0, kern, 'un',0);
</span><span class="comment">    %   kern    cell {npart x 1}
</span><span class="comment">    %   cellfun permite aplicar una funci&#65533;n a cada elemento del cell. En
</span><span class="comment">    %   este caso multiplica todas las matrices por 0. Se hace para inciar
</span><span class="comment">    %   el arreglo en 0's.
</span><span class="comment">
</span><span class="comment">    dkernx = kern;  %   cell {npart x 1}
</span><span class="comment">    dkerny = kern;  %   Derivadas del kern iniciadas en 0&#65533;s
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">    for i = 1:numpart
</span><span class="comment">
</span><span class="comment">        % Calculo de Kernel
</span><span class="comment">        kern{i} = kern1(Dist{i},h);
</span><span class="comment">        dkernx{i} = dkernx1(Dist{i}, h, coorbar, Nearpart{i}, i);
</span><span class="comment">        dkerny{i} = dkerny1(Dist{i}, h, coorbar, Nearpart{i}, i);
</span><span class="comment">%{
</span><span class="comment">    Para la part&#65533;cula i, se calcula el kernel evaluado en sus n part&#65533;culas
</span><span class="comment">    vecinas.
</span><span class="comment">    Para la part&#65533;cula i, se calculan las derivadas x &amp; y del kernel
</span><span class="comment">    evaluados en las particulas vecinas.
</span><span class="comment">%}
</span><span class="comment">        %%
</span><span class="comment">        % Ecuaci&#65533;n de estado Mie Gruniensen
</span><span class="comment">        P(i) = EOSmie(eint(i), r0, C, S, Rho(i), gamma);
</span><span class="comment">%{
</span><span class="comment">    Para la part&#65533;cula i, se calcula la presi&#65533;n hidrost&#65533;tica en funci&#65533;n de
</span><span class="comment">    las demas variables de Estado. El calculo se hace usando la Ecuaci&#65533;n de
</span><span class="comment">    Mie-Grniensen. Las variables de estado consisten en enrg&#65533;a interna,
</span><span class="comment">    densiada y Parametros de la curva de Huggoniot.
</span><span class="comment">%}
</span><span class="comment">        %%
</span><span class="comment">        % Derivada Espacial de Velocidad
</span><span class="comment">        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = ...
</span><span class="comment">            Velgradesp(Rho, M, V1, V2, dkernx{i,1}, dkerny{i,1},...
</span><span class="comment">            Nearpart{i,1}, i);
</span><span class="comment">%{
</span><span class="comment">    Para la part&#65533;cula i, se calculan las derivadas espaciales en
</span><span class="comment">    direcciones 1 y 2 para las componentes de velocidad V1 y V2. El c&#65533;lculo
</span><span class="comment">    se hace con aproximaci&#65533;n por part&#65533;culas vecinas.
</span><span class="comment">%}
</span><span class="comment">        %%
</span><span class="comment">        % Deformacion unitaria
</span><span class="comment">        [eps11(i), eps12(i), eps21(i), eps22(i)] = ...
</span><span class="comment">            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));
</span><span class="comment">%   Para la part&#65533;cula i, calcula lasc componentes del tensor dedeformaci&#65533;n
</span><span class="comment">
</span><span class="comment">        %%
</span><span class="comment">        % Derivadas de Esfuerzos Cortantes
</span><span class="comment">        [ddev11(i), ddev12(i), ddev21(i), ddev22(i)] = ...
</span><span class="comment">            devstresshooke(dv1dx2(i), dv2dx1(i),...
</span><span class="comment">                dev11(i), dev12(i), dev21(i), dev22(i),...
</span><span class="comment">                eps11(i), eps21(i), eps22(i), G);
</span><span class="comment">%  Para la part&#65533;cula i, calcula las componentes del tensor de esfuerzos
</span><span class="comment">
</span><span class="comment">        dev11(i) = dev11(i) + ddev11(i)*dt;
</span><span class="comment">        dev12(i) = dev12(i) + ddev12(i)*dt;
</span><span class="comment">        dev21(i) = dev21(i) + ddev21(i)*dt;
</span><span class="comment">        dev22(i) = dev22(i) + ddev22(i)*dt;
</span><span class="comment">%{
</span><span class="comment">    Una vez calculada la derivada de los esfuerzos para la particula i,
</span><span class="comment">    los esfuerzos para la part&#65533;cula i se calculan con un incremento
</span><span class="comment">    infinitesimal de tiempo.
</span><span class="comment">%}
</span><span class="comment">       %%
</span><span class="comment">       % Von Mises
</span><span class="comment">       J = (dev11(i)^2) + 2*dev12(i)*dev21(i) + (dev22(i)^2);
</span><span class="comment">       fact = sqrt(2*Yo/3);
</span><span class="comment">
</span><span class="comment">       if J&gt;Yo*3/2
</span><span class="comment">           scalar = fact/sqrt(J);
</span><span class="comment">           dev11(i) = dev11(i)*scalar;
</span><span class="comment">           dev12(i) = dev12(i)*scalar;
</span><span class="comment">           dev21(i) = dev21(i)*scalar;
</span><span class="comment">           dev22(i) = dev22(i)*scalar;
</span><span class="comment">       end
</span><span class="comment">       % * preguntar po est parte ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*****
</span><span class="comment">       %Calculo del da&#65533;o
</span><span class="comment">        ei = J/((1-D(i))*E);
</span><span class="comment">
</span><span class="comment">        for j=1:length(Flaws{i});
</span><span class="comment">            count = 0;
</span><span class="comment">            if ei&gt;length(Flaws{i}(j)) %Posible error, Flaws{i}(j) es un
</span><span class="comment">                %double, por lo que length(flaws{i}(j)) siempre es 1.
</span><span class="comment">                count = count+1;
</span><span class="comment">            end
</span><span class="comment">        end
</span><span class="comment">
</span><span class="comment">        dD = (Damageevol(Rho(i), M(i), cs(i)))*count;
</span><span class="comment">        D(i) = (dD^2)*dt;
</span><span class="comment">
</span><span class="comment">        dev11(i) = dev11(i)*(1-D(i));
</span><span class="comment">        dev12(i) = dev12(i)*(1-D(i));
</span><span class="comment">        dev22(i) = dev22(i)*(1-D(i));
</span><span class="comment">        dev22(i) = dev21(i)*(1-D(i));
</span><span class="comment">        % Alivio de Esfuerzos generado por da&#65533;o
</span><span class="comment">        %%
</span><span class="comment">        % Ecuaci&#65533;n de Continuidad
</span><span class="comment">        drho(i) = derivadarho(M, V1, V2,...
</span><span class="comment">            dkernx{i,1}, dkerny{i,1}, Nearpart{i,1}, i);
</span><span class="comment">    % Calcula la derivada de la densidad para la particula i
</span><span class="comment">    end
</span><span class="comment">
</span><span class="comment">    % Paso de tiempo
</span><span class="comment">    for i=1:numpart;
</span><span class="comment">        Rho(i) = Rho(i) + dt*drho(i); % Cambia la densidad en el tiempo
</span><span class="comment">    end
</span><span class="comment">
</span><span class="comment">    for i=1:numpart
</span><span class="comment">        % Ecuacion de Momentum
</span><span class="comment">        [dV1(i),dV2(i)] = Momentumeq2d(dev11, dev12, dev21, dev22,...
</span><span class="comment">            P, Rho, dkernx{i,1}, dkerny{i,1}, M, Nearpart{i,1},...
</span><span class="comment">            i, cs, Dist{i,1}, coorglobal, h, V1, V2);
</span><span class="comment">
</span><span class="comment">        % Conservacion de Energia
</span><span class="comment">        deint(i) = Deint(dev11(i), dev12(i), dev21(i), dev22(i),...
</span><span class="comment">            P, Rho, dkernx{i,1}, dkerny{i,1}, M, Nearpart{i,1},...
</span><span class="comment">            i, cs, Dist{i,1}, coorglobal, h, V1, V2,...
</span><span class="comment">            eps11(i), eps12(i), eps21(i), eps22(i));
</span><span class="comment">    end
</span><span class="comment">    %%
</span><span class="comment">    V1(1:length(dV1),1) = V1(1:length(dV1),1) + dt*dV1;
</span><span class="comment">    V2(1:length(dV2),1) = V2(1:length(dV2),1) + dt*dV2;
</span><span class="comment">    eint(1:length(deint),1)=eint(1:length(deint),1) + deint*dt;
</span><span class="comment">    % Cambia la energia interna y las velocidades acorde al paso de tiempo
</span><span class="comment">    % y las derivadas calculadas
</span><span class="comment">
</span><span class="comment">    %% Correcciones
</span><span class="comment">    for i=1:numpart
</span><span class="comment">       %Velocidad del sonido
</span><span class="comment">       cs(i) = Miespeedofsound(eint(i), r0, C, S, Rho(i), gamma);
</span><span class="comment">       %XSPH
</span><span class="comment">       [V1(i), V2(i)] = XSPH(Nearpart{i,1}, M, Rho, V1, V2, kern{i,1}, i);
</span><span class="comment">       % Actualizar posiciones
</span><span class="comment">       coorbar(i,:) = coorbar(i,:) + [V1(i), V2(i)]*dt;
</span><span class="comment">    end
</span><span class="comment">    %%
</span><span class="comment">    t = t + dt;
</span><span class="comment">    figure(2)
</span><span class="comment">    plot(coorbar(:,1), coorbar(:,2),'.b')
</span><span class="comment">    axis([-0.0254 0.0254 -0.0254*2 0.0254*2])
</span><span class="comment">    drawnow
</span><span class="comment">
</span><span class="comment">    %%Guardar Info de la simulaci&#65533;n.
</span><span class="comment">    Coordenadas(:,:,ti) = coorbar;
</span><span class="comment">    Velocidad1(:,:,ti) = V1;
</span><span class="comment">    Velocidad2(:,:,ti) = V2;
</span><span class="comment">    Presion(:,:,ti) = P;
</span><span class="comment">    Esfuerzos11(:,:,ti) = dev11;
</span><span class="comment">    Esfuerzos12(:,:,ti) = dev12;
</span><span class="comment">    Esfuerzos21(:,:,ti) = dev21;
</span><span class="comment">    Esfuerzos22(:,:,ti) = dev22;
</span><span class="comment">    Densidad(:,:,ti) = Rho;
</span><span class="comment">    % Con estas matrices grabo las posiciones y propiedades de todas las
</span><span class="comment">    % particulas para cada incremento de tiempo
</span><span class="comment">end
</span><span class="comment">%% Referencias
</span><span class="comment">%{
</span><span class="comment">[1] D.Luna &amp; A. Gonzalez, Estudio computacional de la fragmentaci&#65533;n de
</span><span class="comment">materiales fragiles con el m&#65533;todo de particulas suavizadas (SPH), Uniandes,
</span><span class="comment">2015.
</span><span class="comment">
</span><span class="comment">[2] G.R. Liu &amp; M.B. Liu, Smoothed Particle Hydrodynamics - a meshfree particle
</span><span class="comment">ethod, World Scientifics Publishing Co., 2003.
</span><span class="comment">%}
</span><span class="comment">
</span><span class="comment">%% Comentarios JC
</span><span class="comment">%{
</span><span class="comment">Hasta aca entiendo todo
</span><span class="comment">Hay algunas modificaciones que quisiera hacer. Todas consisten en
</span><span class="comment">modificaicones de estilo, por ejemplo: crear una matriz de 0's en lugar de
</span><span class="comment">crear una matriz de 1's y multiplicarla por 0
</span><span class="comment">%}
</span><span class="comment">%}</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Jc_tensile
%{
Este script consiste en una copia de el escript tensileroadsph.m autoria de
ing. Daniel Luna. 
Desarrollo este script para entender la estructura general del c�digo de
referencia.
%}
clear all;clc;
%% Constantes
%{
Todas las unidades en sistema internacional de unidades
%}
dy = 0.000384848;   %   [1x1] separacion entre particulas-
dx = dy;            %-
hdx = 2.0;          %   [#] cte para expandir radio-
h = hdx*dx;         %   [#] Radio para dominio soporte-

r0 = 7850;          %   [#] densidad volumetrica del acero
m0 = dx*dy*r0;      %   [#] masa de una particula. (dz=1)
v_s = 300;          %   [#] velocidad incial
    
    ss = 4699;      %   [#]  REPLACE_WITH_DASH_DASH-
    C = 3630;       %   [#] Huggoniot
    S = 1800;       %   [#]  REPLACE_WITH_DASH_DASH-
    
    gamma = 1.81;   %   [#]  REPLACE_WITH_DASH_DASH-
    alpha = 0.5;    %   [#]
    beta = 0.5;     %   [#] XSPH
    eta = 0.01;     %   [#]
    eps = 0.5;      %   [#]  REPLACE_WITH_DASH_DASH-
    
bar_width = 0.0076; %   [#] Ancho de la barra-
G = 8*10^10;        %   [#] Modulo Cortante
Yo = 6*10^8;        %   [#] Esfuerzo de fluencia
E = ss^2*r0;        %   [#] Modulo de Young - calculado con parametros 
                    %        de Huggoniot
ro2 = 2750;         %   [#] Densidad aluminio ~ creo que es la densidad 
                    %        del proyectil
platestart = -2*bar_width; %[#] Dominio 2D debe empezar en esta posici�n 
plateend = 2*bar_width;    %[#] Dominio 2D debe terminar en esta posici�n
    
    m = 3;          %   [#] parametros de Weibull para generacion de
    k = 7;          %   [#] fractuas al interior del material
    
V = dx*dy;          %   [#] Volumen infinitesimal
dt = 1*10^-7;       %   [#] Paso de tiempo
tf = 1e-6*20;       %   [#] Tiempo final

%% Definir Geoemtr�a
%{
En esta secci�n se crean las posiciones de las particulas y se asginan las
fallas.
%}
xbar = -bar_width/2:dx:bar_width/2+dx;  % [#:dx:#] posiciones en x-
ybar = 0:dy:0.0254;         %   [#:dy:#]    posiciones en y-
[X,Y] = meshgrid(xbar,ybar);%   [Matriz]    Matrices que con la malla -
                            %       de las posiciones para las particulas-

coorbar = [X(:),Y(:)];      %   | x_1 , y_1 |   En esta matriz organiza   - 
                            %   | .   , .   |   todas las posiciones de las
                            %   | x_n , y_n |   particulas. -
                            %   [npart x 2] -

numrpart = length(X(:));    %   [#] Numero de particulas. ~size(1,coorbar) -
Nflaws = numrpart*log(numrpart);%[#] Numero de fallas en el material-
Nflaws = round(Nflaws);         % ~Modelo de fallas-
Flawpart = randi(numrpart,Nflaws,1,'uint32'); %[Nflaws x 1]
                            %   vector que contiene # aleatorio entre 1 y
                            %   numpart para cada una de las Nflaws
coorglobal = coorbar;       %   [Matriz] copia de la matriz coorbar
numpart = numrpart;         %   [#] copia de numero de particulas

[Flaws{1:numrpart,1}] = deal(zeros(0)); % Flaws [cell array] {numrpart x 1}
                            %   Cell array con 'numrpart' matrices vacias
                            %   Cell de prealocaci�n para fallas
randi(
for i = 1:length(Flawpart)                            
    Flaws{Flawpart(i),1}(size(Flaws{Flawpart(i),1})+1) = (i/(k*V))^(1/m);
end
% Flawpart  [Nflaws x 1]     vector que contiene Nflaws posiciones de las 
% fallas a generar. Las posiciones estan dadas como numeros enteros en 
% relaci�n al n�mero de cada part�cula.
% Flaws     cell{numrpart x 1}  contiene 'numrpart' matrices vacias que 
% identifican las fallas para cada particula.
% Flaws se va llenando con las posciones que indica Flawpart. La primera
% vez que pasa por una matriz de Flaws, le imprime el n�mero 
% entero (i/(k*v))^(1/m) formando una matriz 1x1. La segunda vez que pasa 
% por la misma matriz, aumenta la dimension de la matriz en una sola
% direccion para imprimir otro n�mero entero. As�, si semialeatoriamente,
% el numero 'k' aparecio 'n' veces en Flawpart, la celda Flaws en su
% posicion 'k' debe contener una matriz nx1 de n�mero enteros.
%{
%% Otras Matrices
% ~Luna no espececifica comentarios para estas matrices
M = (ones(numpart,1))*dx*dy*r0; %[numpart x 1] Masa de las particulas
Rho = (ones(numpart,1))*r0;     %[numpart x 1] Densidad de las particulas
drho = zeros(numpart,1);        %[numpart x 1] Derivada de la densidad
D = zeros(numpart,1);           %[numpart x 1] Da�o de cada part�cula [0 1]
cs = ss*ones(numpart,1);        %[numpart x 1] ~Velocidad del sonido

%% Velocidades
V1 = zeros(numpart,1);          %[numpart x 1] Velocidad 1 -> 0's
V2 = ones(numpart,1);           %[numpart x 1] Velocidad 2 -> 1�s

Vdistr = linspace(-v_s,v_s,67); %[1 x 67] Distribucion de velocidad
                                % vector fila, espacio discretizado en 67
                                % puntos desde -v_s hasta v_s
for i=1:(numrpart/67) 
    V2((i-1)*67+1:i*67) = Vdistr';
end
% El recorrido se realiza numpart/67 = 1407/67 = 21 veces. En cada uno de
% los recorridos, Vdistr se convierte a columna y se guarda en V2. As�,
% Vdistr se repite 21 veces dentro de V2. Creo que el #67 se debe a la
% forma en la que esta creada la malla, indicando que la distribuci�n de
% velocidad se realiza sobre 67 particulas en fila.

Velplot = zeros(size(X));       % [Matriz] Matriz para graficar. Tiene el 
                                %   mismo tama�o que la matriz de malla X.
for i=1:numpart
   Velplot(i) = V2(i);
end
% La matriz Velplot se llena con los datos del vector V2. De esta forma,
% Velplot queda con 21 columnas de 67 filas. Cada Columna conteniendo el
% vector Vdistr

%image([-100 100], [-100 100], Velplot, 'CDataMapping', 'scaled');
%xlabel('X (normalizado a 100)'); ylabel('Y (normalizado a 100)');colorbar;
% Grafica Velplot como una im�gen. En x se presentan 21 puntos y en y se
% presentan 67 puntos. La velocidad no cambia con x.

%% Derivadas
%{
Aca se inicializan las matrices de todas las derivadas
%}

% Aceleracion
dV1 = zeros(numpart,1);     %[numpart x 1] Derivada total de V1
dV2 = zeros(numpart,1);     %[numpart x 1] Derivada total de V2
    % Derivadas Espaciales
    dv1dx1 = zeros(numpart,1);  %[numpart x 1] Derivada V1 en dir 1 (x)
    dv1dx2 = zeros(numpart,1);  %[numpart x 1] Derivada V1 en dir 2 (y)
    dv2dx1 = zeros(numpart,1);  %[numpart x 1] Derivada V2 en dir 1 (x)
    dv2dx2 = zeros(numpart,1);  %[numpart x 1] Derivada V2 en dir 2 (y)

P = zeros(numpart,1);       %[numpart x 1] Presion Hidrostatica

% Esfuerzos
dev11 = zeros(numpart,1);   % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
dev12 = zeros(numpart,1);   % Esfuerzos Cortantes
dev21 = zeros(numpart,1);   % [numpart x1]
dev22 = zeros(numpart,1);   % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    % Derivadas Espaciales
    ddev11 = zeros(numpart,1);  %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    ddev12 = zeros(numpart,1);  % Derivadas Espaciales de los esfuerzos
    ddev21 = zeros(numpart,1);  % [numpart x 1]
    ddev22 = zeros(numpart,1);  %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Deformaciones
eps11 = zeros(numpart,1);   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
eps12 = zeros(numpart,1);   % Deformacion Unitaria
eps21 = zeros(numpart,1);   %   [numpart x 1]
eps22 = zeros(numpart,1);   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

eint = zeros(numpart,1);    % Energ�a interna y derivada
deint = zeros(numpart,1);   %   [numpart x 1]
%% Incio de la simulaci�n
%{
Aca se corre la simulaci�nn
%}
display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
display('   Inicio de la Simulaci�n   ');
display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');

t = 0;              %   int     Tiempo inicial
steps = tf/dt;      %   int     Numero de pasos

% Matrices para guardar informaci�n de la simulaci�n.
Coordenadas = zeros([size(coorbar), steps]);
Velocidad1 = zeros([size(V1),steps]);
Velocidad2 = zeros([size(V2),steps]);
Presion = zeros([size(P),steps]);
Esfuerzos11 = zeros([size(dev11), steps]);
Esfuerzos12 = zeros([size(dev12), steps]);
Esfuerzos21 = zeros([size(dev21), steps]);
Esfuerzos22 = zeros([size(dev22), steps]);
Densidad = zeros([size(Rho), steps]);

for ti=1:steps
%%
    fprintf('P %d/%d \n',ti,steps);
    %~~~~~ Inicializaci�n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [Nearpart,Dist] = rangesearch(coorbar,coorbar,h);
    %   Nearpart    cell {npart x 1} 
    %   En el compartimiento i de Nearpart, se encuentra un vector [1 x n] 
    %   que contiene los indices de las n particulas vecinas a la part�cula
    %   de identidad i.
    %   Dist        cell {npart x 1} 
    %   En el compartimiento i de Dist, se encuentra un vector [1 x n] que 
    %   contiene la distancia r_n a la que se encuentra cada una de las n
    %   particulas vecinas de la part�cula i.
    
    kern = Dist;    %   cell {npart x 1}    kern contiene npart vectores, 
                        % uno para cada particula. Cada vector mide [1x ni] 
                        % siendo ni el numero de particulas vecinas de la 
                        % particula i 
    
    kern = cellfun(@(x) x*0, kern, 'un',0);
    %   kern    cell {npart x 1}
    %   cellfun permite aplicar una funci�n a cada elemento del cell. En
    %   este caso multiplica todas las matrices por 0. Se hace para inciar
    %   el arreglo en 0's.
    
    dkernx = kern;  %   cell {npart x 1} 
    dkerny = kern;  %   Derivadas del kern iniciadas en 0�s

    
    for i = 1:numpart 
    
        % Calculo de Kernel
        kern{i} = kern1(Dist{i},h);
        dkernx{i} = dkernx1(Dist{i}, h, coorbar, Nearpart{i}, i);
        dkerny{i} = dkerny1(Dist{i}, h, coorbar, Nearpart{i}, i);        
%{ 
    Para la part�cula i, se calcula el kernel evaluado en sus n part�culas
    vecinas.
    Para la part�cula i, se calculan las derivadas x & y del kernel
    evaluados en las particulas vecinas.  
%}
        %%
        % Ecuaci�n de estado Mie Gruniensen
        P(i) = EOSmie(eint(i), r0, C, S, Rho(i), gamma);
%{
    Para la part�cula i, se calcula la presi�n hidrost�tica en funci�n de
    las demas variables de Estado. El calculo se hace usando la Ecuaci�n de
    Mie-Grniensen. Las variables de estado consisten en enrg�a interna,
    densiada y Parametros de la curva de Huggoniot.
%}
        %%
        % Derivada Espacial de Velocidad
        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = ...
            Velgradesp(Rho, M, V1, V2, dkernx{i,1}, dkerny{i,1},...
            Nearpart{i,1}, i);
%{
    Para la part�cula i, se calculan las derivadas espaciales en
    direcciones 1 y 2 para las componentes de velocidad V1 y V2. El c�lculo
    se hace con aproximaci�n por part�culas vecinas.
%}
        %%
        % Deformacion unitaria
        [eps11(i), eps12(i), eps21(i), eps22(i)] = ...
            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));
%   Para la part�cula i, calcula lasc componentes del tensor dedeformaci�n

        %%
        % Derivadas de Esfuerzos Cortantes
        [ddev11(i), ddev12(i), ddev21(i), ddev22(i)] = ...
            devstresshooke(dv1dx2(i), dv2dx1(i),...
                dev11(i), dev12(i), dev21(i), dev22(i),...
                eps11(i), eps21(i), eps22(i), G);
%  Para la part�cula i, calcula las componentes del tensor de esfuerzos              

        dev11(i) = dev11(i) + ddev11(i)*dt;
        dev12(i) = dev12(i) + ddev12(i)*dt;
        dev21(i) = dev21(i) + ddev21(i)*dt;
        dev22(i) = dev22(i) + ddev22(i)*dt;
%{
    Una vez calculada la derivada de los esfuerzos para la particula i, 
    los esfuerzos para la part�cula i se calculan con un incremento
    infinitesimal de tiempo.
%}
       %%
       % Von Mises
       J = (dev11(i)^2) + 2*dev12(i)*dev21(i) + (dev22(i)^2);
       fact = sqrt(2*Yo/3);
       
       if J>Yo*3/2
           scalar = fact/sqrt(J);
           dev11(i) = dev11(i)*scalar;
           dev12(i) = dev12(i)*scalar;
           dev21(i) = dev21(i)*scalar;
           dev22(i) = dev22(i)*scalar;
       end
       % * preguntar po est parte ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*****
       %Calculo del da�o
        ei = J/((1-D(i))*E);
        
        for j=1:length(Flaws{i});
            count = 0;
            if ei>length(Flaws{i}(j)) %Posible error, Flaws{i}(j) es un 
                %double, por lo que length(flaws{i}(j)) siempre es 1.
                count = count+1;
            end
        end
        
        dD = (Damageevol(Rho(i), M(i), cs(i)))*count;
        D(i) = (dD^2)*dt;
            
        dev11(i) = dev11(i)*(1-D(i));
        dev12(i) = dev12(i)*(1-D(i));
        dev22(i) = dev22(i)*(1-D(i));
        dev22(i) = dev21(i)*(1-D(i));
        % Alivio de Esfuerzos generado por da�o
        %%
        % Ecuaci�n de Continuidad
        drho(i) = derivadarho(M, V1, V2,...
            dkernx{i,1}, dkerny{i,1}, Nearpart{i,1}, i);
    % Calcula la derivada de la densidad para la particula i
    end
    
    % Paso de tiempo
    for i=1:numpart;
        Rho(i) = Rho(i) + dt*drho(i); % Cambia la densidad en el tiempo
    end
    
    for i=1:numpart
        % Ecuacion de Momentum
        [dV1(i),dV2(i)] = Momentumeq2d(dev11, dev12, dev21, dev22,...
            P, Rho, dkernx{i,1}, dkerny{i,1}, M, Nearpart{i,1},...
            i, cs, Dist{i,1}, coorglobal, h, V1, V2);
        
        % Conservacion de Energia
        deint(i) = Deint(dev11(i), dev12(i), dev21(i), dev22(i),...
            P, Rho, dkernx{i,1}, dkerny{i,1}, M, Nearpart{i,1},...
            i, cs, Dist{i,1}, coorglobal, h, V1, V2,...
            eps11(i), eps12(i), eps21(i), eps22(i));
    end
    %%
    V1(1:length(dV1),1) = V1(1:length(dV1),1) + dt*dV1;
    V2(1:length(dV2),1) = V2(1:length(dV2),1) + dt*dV2;
    eint(1:length(deint),1)=eint(1:length(deint),1) + deint*dt; 
    % Cambia la energia interna y las velocidades acorde al paso de tiempo
    % y las derivadas calculadas
    
    %% Correcciones
    for i=1:numpart
       %Velocidad del sonido
       cs(i) = Miespeedofsound(eint(i), r0, C, S, Rho(i), gamma);
       %XSPH
       [V1(i), V2(i)] = XSPH(Nearpart{i,1}, M, Rho, V1, V2, kern{i,1}, i);
       % Actualizar posiciones
       coorbar(i,:) = coorbar(i,:) + [V1(i), V2(i)]*dt;
    end
    %%
    t = t + dt;
    figure(2)
    plot(coorbar(:,1), coorbar(:,2),'.b')
    axis([-0.0254 0.0254 -0.0254*2 0.0254*2])
    drawnow
    
    %%Guardar Info de la simulaci�n.
    Coordenadas(:,:,ti) = coorbar;
    Velocidad1(:,:,ti) = V1;
    Velocidad2(:,:,ti) = V2;
    Presion(:,:,ti) = P;
    Esfuerzos11(:,:,ti) = dev11;
    Esfuerzos12(:,:,ti) = dev12;
    Esfuerzos21(:,:,ti) = dev21;
    Esfuerzos22(:,:,ti) = dev22;
    Densidad(:,:,ti) = Rho;
    % Con estas matrices grabo las posiciones y propiedades de todas las
    % particulas para cada incremento de tiempo
end
%% Referencias
%{
[1] D.Luna & A. Gonzalez, Estudio computacional de la fragmentaci�n de
materiales fragiles con el m�todo de particulas suavizadas (SPH), Uniandes,
2015.

[2] G.R. Liu & M.B. Liu, Smoothed Particle Hydrodynamics - a meshfree particle
ethod, World Scientifics Publishing Co., 2003.
%}

%% Comentarios JC
%{
Hasta aca entiendo todo
Hay algunas modificaciones que quisiera hacer. Todas consisten en
modificaicones de estilo, por ejemplo: crear una matriz de 0's en lugar de
crear una matriz de 1's y multiplicarla por 0
%}
%}
##### SOURCE END #####
--></body></html>