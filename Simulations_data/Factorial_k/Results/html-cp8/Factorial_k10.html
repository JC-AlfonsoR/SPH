
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Factorial_k10</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-04-20"><meta name="DC.source" content="Factorial_k10.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Bullet_Impact</a></li><li><a href="#2">Definir Geometria del Objetivo</a></li><li><a href="#3">Asignacion de defectos puntuales en Objetivo</a></li><li><a href="#5">Constantes del Material Objetivo</a></li><li><a href="#6">Definir Geometria del Proyectil</a></li><li><a href="#8">Constantes del Material Proyectil</a></li><li><a href="#9">Alocacion de Matrices Requeridas para calculos</a></li><li><a href="#10">Asignacion Selectiva de Propiedades</a></li><li><a href="#11">Asignacion de condiciones iniciales</a></li><li><a href="#12">Representacion de condiciones iniciales</a></li><li><a href="#13">Inicio de Simulacion</a></li><li><a href="#15">Repulsion en la frontera</a></li><li><a href="#16">Recorrido principal en el tiempo</a></li><li><a href="#18">Busqueda de Vecinos</a></li><li><a href="#19">Recorrido en las particulas del Target</a></li><li><a href="#20">Recorrido en las particulas del Bullet</a></li><li><a href="#21">Criterio de falla de Von Mises</a></li><li><a href="#22">Graficas</a></li><li><a href="#24">Comentarios JC</a></li></ul></div><h2>Bullet_Impact<a name="1"></a></h2><p>Simulacion de impacto de taylor. Se define barrera con particulas virtuales que ejercen fuerza de repulsion sobre particulas reales</p><p>v_s = 70 m/s</p><pre class="codeinput">clear <span class="string">all</span>; clc; close <span class="string">all</span>;
</pre><h2>Definir Geometria del Objetivo<a name="2"></a></h2><p>Todas las unidades son dadas en el sistema internacional de unidades</p><p>Se define las posiciones de las particulas que conforman el objetivo</p><p>Geometria del objetivo</p><pre class="codeinput">T_dy = 0.5e-4; <span class="comment">%    Separacion entre particulas</span>
T_dx = T_dy*1;   <span class="comment">%</span>
k = 10.0;   <span class="comment">%    Constante para expandir radio de soporte</span>
h = k*T_dx;  <span class="comment">%    Radio de soporte</span>

T_width = 0.0001;               <span class="comment">% Ancho del objetivo</span>
T_height = 0.005;              <span class="comment">% Alto del objetivo</span>
T_x = linspace(-T_width,T_width,3);
T_y = -T_height : T_dy : T_height;
[X,Y] = meshgrid(T_x, T_y);     <span class="comment">% Matriz con la malla de las posiciones x,y para las particulas</span>
Target = [X(:),Y(:)];           <span class="comment">%   | x_1 , y_1 |   En esta matriz organiza</span>
                                <span class="comment">%   | .   , .   |   todas las posiciones de las</span>
                                <span class="comment">%   | x_n , y_n |   particulas.</span>
                                <span class="comment">%   [T_np x 2]</span>

T_np = size(Target,1);          <span class="comment">% Numero de particulas en el objetivo</span>
</pre><h2>Asignacion de defectos puntuales en Objetivo<a name="3"></a></h2><p>Constantes para asginacion de fallas en basalto</p><pre class="codeinput">m = 3;
k = 7;
T_V = T_dx*T_dy*1;    <span class="comment">% Volumen infinitesimal</span>

Nflaws = T_np*log(T_np);        <span class="comment">% Numero de defectos puntuales a asignar</span>
Nflaws = round(Nflaws);
assign_flaws = randi(T_np,Nflaws,1,<span class="string">'uint32'</span>); <span class="comment">% [Nflaws x 1]</span>
                                <span class="comment">%  Nflaws numeros aleatorios entre 1 y T_np</span>
[Flaws{1:T_np,1}] = deal([]);   <span class="comment">%  Flaws [cell array] {T_np x 1}</span>
                                <span class="comment">%  Cell array con ''T_np matrices vacias</span>
                                <span class="comment">%  Cell de pre-alocacion para fallas</span>

<span class="keyword">for</span> i = 1:Nflaws
    Flaws{assign_flaws(i),1}(size(Flaws{assign_flaws(i),1})+1) = <span class="keyword">...</span>
        (i/(k*T_V))^(1/m);
<span class="keyword">end</span>
</pre><p><b>assign_flaws</b>   [Nflaws x 1]    vector que contiene <i>Nflaws</i> posiciones de las fallas a generar. Las posiciones estan dadas como numeros enteros en relacion al numero de cada particula.</p><p><b>Flaws</b>       cell{T_np x 1}    Contiene <i>T_np</i> matrices vacias que identifican las fallas para cada particula. <b>Flaws</b> se va llenando de forma aleatoria con las posiciones que indica <i>assing_flaws</i>. La primera vez que se pasa por una amtriz de Flaws, le asigna el numero (i/(k*V))^(1/m) formando una matriz 1x1. La segunda vez que se pasa por la misma matriz, aumenta la dimension de la matriz en una sola direccion para asignar otro numero. Asi, si semi-aleatoriamente, el numero <i>k</i> aparecio <i>n</i> veces de <i>assign_flaws</i>, la celda <i>Flaws</i> en su posicion <i>k</i> debe contener una matriz nx1 con numeros asignados. Los numeros asignados corresponden a las deformaciones de activacion para los defectos puntuales de cada particula</p><h2>Constantes del Material Objetivo<a name="5"></a></h2><p>Todas las unidades estan en el sistema internacional de unidades</p><pre class="codeinput">T_rho = 7850;               <span class="comment">%Densidad volumetrica del objetivo</span>
T_m0 = T_dx*T_dy*T_rho;     <span class="comment">%Masa de una particula</span>

<span class="comment">%Parametros de Huggoniot</span>
T_ss = 4699;
T_C = 3630;
T_S = 1800;

<span class="comment">%Parametros de XSPH</span>
T_gamma = 1.81;
T_alpha = 0.5;
T_beta = 0.5;
T_eta = 0.01;
T_eps = 0.5;

<span class="comment">%Parametros de Elasticidad</span>
T_G = 8e10;         <span class="comment">% Modulo de cortante</span>
T_Y0 = 6e20;         <span class="comment">% Esfuerzo de fluencia % Cambio de e8 a e20</span>
T_E = T_ss^2*T_rho;   <span class="comment">% Modulo de Young</span>
</pre><h2>Definir Geometria del Proyectil<a name="6"></a></h2><p>Se definen las posiciones de las particulas que conforman el proyectil.</p><p>Se asume que el proyectil se mueve en la direccion horizontal.</p><p>Proyectil rectangular</p><pre class="codeinput">s_x = h/5;             <span class="comment">% Separacion en x entre proyectil y objetivo</span>
B_width = 0.003;    <span class="comment">% Ancho del proyectil</span>
B_height = 0.002;  <span class="comment">% Alto del proyectil</span>
B_x0 = min(Target(:,1))-B_width-s_x;
B_y0 = mean(Target(:,2)); <span class="comment">% Posiciones de referencia para el objetivo</span>
B_dx = 1e-4;            <span class="comment">% Separacion entre particulas del proyectil</span>
B_dy = 2e-4;

B_x = [-B_width : B_dx : B_width] + B_x0;
B_y = [-B_height : B_dy : B_height] + B_y0;
[X,Y] = meshgrid(B_x,B_y);  <span class="comment">% Matrices con la malla para las posiciones</span>
                            <span class="comment">% de la particulas en el proyectil</span>
Bullet = [X(:),Y(:)];       <span class="comment">% Posicion de las particulas en el pryectil</span>
B_np = size(Bullet,1);      <span class="comment">% Numero de particulas en el proyectil</span>
<span class="comment">%}</span>
</pre><p>Proyectil redondo</p><pre class="codeinput"><span class="comment">%{
</span><span class="comment">s_x = h/5;         % separacion en x entre proyectil y objetivo
</span><span class="comment">B_dr = 1e-4;        % Variacion en el radio del proyectil
</span><span class="comment">B_rmax = 0.002;  % Radio maximo del proyectil
</span><span class="comment">B_r = B_dr:B_dr:B_rmax; % Valores del radio en el proyectil
</span><span class="comment">n_theta = 18*2;         % Numero de puntos a considerar en el angulo
</span><span class="comment">B_theta = linspace(0,2*pi,n_theta); % Valores del angulo
</span><span class="comment">B_cx = min(Target(:,1)) - B_rmax - s_x; % Centro del proyectil
</span><span class="comment">B_cy = mean(Target(:,2));
</span><span class="comment">B_np = length(B_r)*length(B_theta); %Numero de particulas en el proyectil
</span><span class="comment">Bullet = zeros(B_np,2); % Posiciones x,y de las particulas en el proyectil
</span><span class="comment">for i = 1:length(B_r)
</span><span class="comment">    for j = 1:length(B_theta)
</span><span class="comment">        Bullet((i-1)*n_theta+j,:) = [B_r(i)*cos(B_theta(j))+B_cx,...
</span><span class="comment">            B_r(i)*sin(B_theta(j))+B_cy];
</span><span class="comment">    end
</span><span class="comment">end
</span><span class="comment">%}
</span><span class="comment">%</span>
</pre><h2>Constantes del Material Proyectil<a name="8"></a></h2><p>Por el momento estas magnitudes corresponden a las mismas del objetivo</p><p><b>*Consultar Propiedades para algun metal y reemplazaralas</b>*</p><pre class="codeinput">B_rho = 7850;               <span class="comment">%Densidad volumetrica del objetivo</span>
<span class="comment">%B_m0 = pi*B_dr^2*B_rho;     %Masa de una particula -Cilindrico</span>
B_m0 = B_dx*B_dy*B_rho;
<span class="comment">%B_V = pi*B_dr^2*1; % Circular</span>
B_V = B_dx*B_dy;
<span class="comment">%Parametros de Huggoniot</span>
B_ss = 4699;
B_C = 3630;
B_S = 1800;

<span class="comment">%Parametros de XSPH</span>
B_gamma = 1.81;
B_alpha = 0.5;
B_beta = 0.5;
B_eta = 0.01;
B_eps = 0.5;

<span class="comment">%Parametros de Elasticidad</span>
B_G = 8e10;             <span class="comment">% Modulo de cortante</span>
B_Y0 = 6e8;             <span class="comment">% Esfuerzo de fluencia</span>
B_E = T_ss^2*T_rho;     <span class="comment">% Modulo de Young</span>
</pre><h2>Alocacion de Matrices Requeridas para calculos<a name="9"></a></h2><pre class="codeinput">N_part = T_np + B_np; <span class="comment">% Numero total de particulas</span>

Particles = [Target;Bullet];    <span class="comment">% Posiciones de particulas</span>
V1 = zeros(N_part,1);   <span class="comment">% Velocidad en la direccion 1</span>
V2 = zeros(N_part,1);
dV1 = zeros(N_part,1);  <span class="comment">% Derivada total de V1</span>
dV2 = zeros(N_part,1);
    dv1dx1 = zeros(N_part,1);
    dv1dx2 = zeros(N_part,1);   <span class="comment">% Derivada de V1 en direccion 2</span>
    dv2dx1 = zeros(N_part,1);
    dv2dx2 = zeros(N_part,1);
P = zeros(N_part,1);    <span class="comment">% Presion Hidrostatica</span>

Tau11 = zeros(N_part,1);
Tau12 = zeros(N_part,1);    <span class="comment">% Esfuerzos en cara 1 con direccion 2</span>
Tau21 = zeros(N_part,1);
Tau22 = zeros(N_part,1);
    dTau11 = zeros(N_part,1);
    dTau12 = zeros(N_part,1); <span class="comment">% Derivada de esfuerzos en cara 1 con dir 2</span>
    dTau21 = zeros(N_part,1);
    dTau22 = zeros(N_part,1);

eps11 = zeros(N_part,1);
eps12 = zeros(N_part,1);    <span class="comment">% Deformacion unitaria en cara 1 con dir 2</span>
eps21 = zeros(N_part,1);
eps22 = zeros(N_part,1);

E_int = zeros(N_part,1);        <span class="comment">% Energia Interna</span>
    dE_int = zeros(N_part,1);   <span class="comment">% Derivada de Energia Interna</span>
</pre><h2>Asignacion Selectiva de Propiedades<a name="10"></a></h2><p>Hay que revisar esta matrices porque las propiedades deben inicializarse de acuerdo al <i>tipo de las particulas</i>, es decir que se deben asignar propiedades diferentes a las particulas del <b>objetivo</b> y a las particulas del <b>proyectil</b></p><pre class="codeinput">M = zeros(N_part,1);        <span class="comment">% Masa de las particulas</span>
M(1:T_np) = ones(T_np,1)*T_V*T_rho; <span class="comment">% Particulas del objetivo</span>
M(T_np+1:end) = ones(B_np,1)*B_V*B_rho; <span class="comment">% Particulas del proyectil</span>

cs = zeros(N_part,1);       <span class="comment">% Velocidad del sonido</span>
cs(1:T_np) = ones(T_np,1)*T_ss;
cs(T_np+1:end) = ones(B_np,1)*B_ss;

Rho = zeros(N_part,1);      <span class="comment">% Densidad</span>
Rho(1:T_np) = ones(T_np,1)*T_rho;
Rho(T_np+1:end) = ones(B_np,1)*B_rho;

    dRho = zeros(N_part,1); <span class="comment">% Derivada de la densidad</span>

D = zeros(N_part,1);        <span class="comment">% Damage</span>
</pre><h2>Asignacion de condiciones iniciales<a name="11"></a></h2><pre class="codeinput">V_1 = 70;
<span class="comment">%rr = randint(50,1,[1,T_np]);</span>
V1(T_np+1:N_part) = V_1; <span class="comment">% Velocidad inicial del Bullet</span>
<span class="comment">%</span>
</pre><h2>Representacion de condiciones iniciales<a name="12"></a></h2><pre class="codeinput">figure(1)
plot(Target(:,1),Target(:,2),Bullet(:,1),Bullet(:,2),<span class="keyword">...</span>
    <span class="string">'Marker'</span>, <span class="string">'.'</span>, <span class="string">'LineStyle'</span>,<span class="string">'none'</span>)
title(<span class="string">'Configuracion Inicial'</span>)
xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); axis(<span class="string">'equal'</span>)
</pre><img vspace="5" hspace="5" src="Factorial_k10_01.png" alt=""> <h2>Inicio de Simulacion<a name="13"></a></h2><pre class="codeinput">display(<span class="string">'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span>);
display(<span class="string">'   Inicio de la simulacion'</span>)
display(<span class="string">'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span>)

t = 0;  <span class="comment">%Tiempo Inicial</span>
dt = max(h/cs)/2; <span class="comment">% Paso de tiempo</span>
                <span class="comment">% El paso de tiempo se define de esta forma para que la</span>
                <span class="comment">% simulacion sea capaz de detectar el fenomeno mas rapido</span>
                <span class="comment">% al que sea sensible el problema</span>
                <span class="comment">% La definicion correcta es</span>
                <span class="comment">% min(h/cs)</span>
                <span class="comment">% pero lo ejecuta con max para que dt sea diferente de 0 y</span>
                <span class="comment">% la simulacion no sea muy larga</span>
tf = 0.5e-6*20; <span class="comment">% Tiempo final</span>
steps = round(tf/dt);  <span class="comment">% Numero de pasos</span>
</pre><pre class="codeoutput">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Inicio de la simulacion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre><p>Matrices para guardar informacion de la simulacion</p><pre class="codeinput">n_m = round(20/100*steps);     <span class="comment">% Numero de datos para muestreo</span>

Coordenadas = zeros(N_part,n_m);
Velocidad1 = zeros(N_part,n_m);
Velocidad2 = zeros(N_part,n_m);
Presion = zeros(N_part,n_m);
Esfuerzos11 = zeros(N_part,n_m);
Esfuerzos12 = zeros(N_part,n_m);
Esfuerzos21 = zeros(N_part,n_m);
Esfuerzos22 = zeros(N_part,n_m);
Densidad = zeros(N_part,n_m);
</pre><h2>Repulsion en la frontera<a name="15"></a></h2><pre class="codeinput">n1 = 12;
n2 = 4;
D_repulsion  = 5;
r0_repulsion = 2*h;
</pre><h2>Recorrido principal en el tiempo<a name="16"></a></h2><pre class="codeinput">fprintf(<span class="string">'Numero de Pasos = %d\n'</span>,steps)
<span class="keyword">for</span> ti = 1:steps
</pre><pre class="codeinput">    <span class="comment">%fprintf('%d..',ti);</span>
</pre><h2>Busqueda de Vecinos<a name="18"></a></h2><p><b>Nearpart</b>        cell {N_part x 1}: En el compartimiento <i>i</i> de <b>Nearpart</b>, se encuentra un vector [1 x n] que contiene los indices de las n particulas vecinas a la particula de identidad <i>i</i>.</p><p><b>Dist</b>        cell {Npart x 1}: En el compartimiento <i>i</i> de <b>Dist</b>, se encuentra un vector [1 x n] que contiene la distancia <i>r_n</i> a la que se encuentra cada una de las <i>n</i> particulas vecinas de la particula <i>i</i>.</p><pre class="codeinput">    [Nearpart,Dist] = rangesearch(Particles,Particles,h);

    <span class="comment">%</span>
    <span class="comment">% Se genera el _cell_ para el kernel *kern*. Este cell tiene las mismas</span>
    <span class="comment">% dimensiones que el cell _Dist_, con la diferencia que todos los</span>
    <span class="comment">% valores son _0_</span>
    kern = cellfun(@(x) x*0, Dist, <span class="string">'un'</span>, 0);
        dkernx = kern;  <span class="comment">%Inicializar en 0 las derivadas del kernel</span>
        dkerny = kern;

    <span class="comment">% Usando las funciones kern1, dkernx1 y dkerny1 se calcula el kernel</span>
    <span class="comment">% y las derivadas del kernel x-y evaluadas en las particulas vecinas</span>
    <span class="comment">% de cada una de las particulas del dominio.</span>
</pre><h2>Recorrido en las particulas del Target<a name="19"></a></h2><pre class="codeinput">    <span class="keyword">for</span> i = 1:T_np
        kern{i} = kern1(Dist{i},h);
        dkernx{i} = dkernx1(Dist{i}, h, Particles, Nearpart{i}, i);
        dkerny{i} = dkerny1(Dist{i}, h, Particles, Nearpart{i}, i);

        <span class="comment">%%%Calcular Presion hidrostatica con ecuacion de Mie-Gruniensen</span>
        <span class="comment">%</span>
        <span class="comment">%   Esta parte se puede hacer mas eficiente. De esta forma es</span>
        <span class="comment">%   ineficiente porque realiza validacion y asignacion para cada</span>
        <span class="comment">%   particula. Creo que si hago recorridos independientes para las</span>
        <span class="comment">%   particulas del objetivo y del proyectil, solo hago dos</span>
        <span class="comment">%   asignaciones y ninguna verificacion.</span>
        P(i) = EOSmie(E_int(i), T_rho, T_C, T_S, Rho(i), T_gamma);

        <span class="comment">%%%Derivadas espaciales de las Velocidades</span>
        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = <span class="keyword">...</span>
            Velgradesp(Rho, M, V1, V2, dkernx{i}, dkerny{i},<span class="keyword">...</span>
            Nearpart{i},i);

        <span class="comment">%%%Deformacion unitaria</span>
        [eps11(i), eps12(i), eps21(i), eps22(i)] = <span class="keyword">...</span>
            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));

        <span class="comment">%%%Derivadas de Esfuerzos Cortantes</span>
        [dTau11(i), dTau12(i), dTau21(i), dTau22(i)] = <span class="keyword">...</span>
            devstresshooke(dv1dx2(i), dv2dx1(i),<span class="keyword">...</span>
                Tau11(i), Tau12(i), Tau21(i), Tau22(i),<span class="keyword">...</span>
                eps11(i), eps21(i), eps22(i), T_G);

        <span class="comment">%%%Calcular Esfuerzos</span>
        <span class="comment">% No se puede hacer opearacion vectorizada porque el Tau</span>
        <span class="comment">% se corrgie con criterio de Von Mises</span>
        Tau11(i) = Tau11(i) + dTau11(i)*dt;
        Tau12(i) = Tau12(i) + dTau12(i)*dt;
        Tau21(i) = Tau21(i) + dTau21(i)*dt;
        Tau22(i) = Tau22(i) + dTau22(i)*dt;

        <span class="comment">%%%Criterio de falla de Von Mises</span>
        J = Tau11(i)^2 + 2*Tau12(i)*Tau21(i) + Tau22(i)^2;
        f = sqrt(2*T_Y0/3);
        <span class="keyword">if</span> J &gt; T_Y0*3/2
            scalar = f/sqrt(J);
            Tau11(i) = Tau11(i)*scalar;
            Tau12(i) = Tau12(i)*scalar;
            Tau21(i) = Tau21(i)*scalar;
            Tau22(i) = Tau22(i)*scalar;
        <span class="keyword">end</span>

        <span class="comment">%%%Damage</span>
        <span class="comment">% Damage solo aplica para las particulas del Target</span>
        <span class="comment">% Modificacion importante respecto al codigo de Daniel:</span>
        <span class="comment">%</span>
        <span class="comment">% Cambio *if ei &gt; length(Flaws{i}(j))* por</span>
        <span class="comment">% *if ei &gt; Flaws{i}(j)* Hago esta modificacion porque lo que se</span>
        <span class="comment">% necesita es contar cuantos defectos puntuales se activan</span>
        <span class="comment">%</span>
        <span class="comment">%Energia de activacion</span>
        ei = J/((1-D(i))*T_E);

        <span class="comment">% Recorrido en los defectos puntuales</span>
        <span class="keyword">for</span> j = 1:length(Flaws{i})
            count = 0;
            <span class="comment">% Contar cuantos defectos se activan</span>
            <span class="keyword">if</span> ei &gt; Flaws{i}(j)
                count = count + 1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Damage depende del numero de fallas activas</span>
        <span class="comment">% Revisar refrencia de Damage, creo que este procedimiento no es</span>
        <span class="comment">% del todo correcto porque el Damage = 1 se alcanza solo cuando</span>
        <span class="comment">% todas los defectos estan activos. Entonces dberia ser algo de la</span>
        <span class="comment">% forma count/length(Flaws{i})</span>
        <span class="comment">%</span>
        dD = Damageevol(Rho(i), M(i), cs(i)) * count;
        D(i) = dD^2*dt;

        <span class="comment">% Escalar esfuerzos del material con el Damage</span>
        Tau11(i) = Tau11(i)*(1-D(i));
        Tau12(i) = Tau12(i)*(1-D(i));
        Tau21(i) = Tau21(i)*(1-D(i));
        Tau22(i) = Tau22(i)*(1-D(i));


        <span class="comment">%%%Ecuacion de la continuidad</span>
        <span class="comment">% Calcular la derivada de la densidad para una particula</span>
        dRho(i) = derivadarho(M, V1, V2, <span class="keyword">...</span>
            dkernx{i}, dkerny{i}, Nearpart{i}, i);
    <span class="keyword">end</span>

    <span class="comment">%%%Avanzar la densidad en el tiempo</span>
    Rho(1:T_np) = Rho(1:T_np) + dRho(1:T_np)*dt;

    <span class="keyword">for</span> i = 1:T_np
       <span class="comment">%%%Conservacion de Momentum</span>
       [dV1(i),dV2(i)] = Momentumeq2d(Tau11, Tau12, Tau21, Tau22, P, Rho,<span class="keyword">...</span>
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,<span class="keyword">...</span>
           h, V1, V2);

       <span class="comment">%%%%Conservacion de la Energia</span>
       dE_int(i) = Deint(Tau11(i), Tau12(i), Tau21(i), Tau22(i), P, Rho,<span class="keyword">...</span>
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,<span class="keyword">...</span>
           h, V1, V2, eps11(i), eps12(i), eps21(i), eps22(i));
    <span class="keyword">end</span>

    <span class="keyword">for</span> i = 1:T_np
    <span class="comment">%%Repulsion</span>
       [ddV1,ddV2] = Repulsion_frontera(Particles, i, Nearpart, Dist,<span class="keyword">...</span>
           D_repulsion, r0_repulsion, n1, n2, M);
       dV1 = dV1 + ddV1;
       dV2 = dV2 + ddV2;
       <span class="comment">%[dV1, dV2] = [dV1, dV2] + [ddV1,ddV2];</span>
    <span class="keyword">end</span>

    <span class="comment">%%%Avanzar la velocidad</span>
    V1(1:T_np) = V1(1:T_np) + dV1(1:T_np)*dt;
    V2(1:T_np) = V2(1:T_np) + dV2(1:T_np)*dt;
    E_int(1:T_np) = E_int(1:T_np) + dE_int(1:T_np)*dt;

    <span class="comment">%%%Correcciones</span>
    <span class="keyword">for</span> i = 1:T_np
        <span class="comment">%%%Velocidad del sonido</span>
        cs(i) = Miespeedofsound(E_int(i), T_rho, T_C, T_S,Rho(i), T_gamma);

        <span class="comment">%%%XSPH</span>
        [V1(i),V2(i)] = XSPH(Nearpart{i}, M, Rho, V1, V2, kern{i}, i);
    <span class="keyword">end</span>

    <span class="comment">% No muevo las particlas del target</span>
    <span class="comment">%Particles(1:T_np,:) = Particles(1:T_np,:) + ...</span>
    <span class="comment">%    [V1(1:T_np), V2(1:T_np)]*dt;</span>

    <span class="comment">% Hasta aca se tiene configurado completamente la simulacion para</span>
    <span class="comment">% las particulas del target</span>
</pre><h2>Recorrido en las particulas del Bullet<a name="20"></a></h2><pre class="codeinput">    <span class="keyword">for</span> i = T_np+1:N_part
        kern{i} = kern1(Dist{i},h);
        dkernx{i} = dkernx1(Dist{i}, h, Particles, Nearpart{i}, i);
        dkerny{i} = dkerny1(Dist{i}, h, Particles, Nearpart{i}, i);

        <span class="comment">%%%Calcular Presion hidrostatica con ecuacion de Mie-Gruniensen</span>
        <span class="comment">%</span>
        <span class="comment">%   Esta parte se puede hacer mas eficiente. De esta forma es</span>
        <span class="comment">%   ineficiente porque realiza validacion y asignacion para cada</span>
        <span class="comment">%   particula. Creo que si hago recorridos independientes para las</span>
        <span class="comment">%   particulas del objetivo y del proyectil, solo hago dos</span>
        <span class="comment">%   asignaciones y ninguna verificacion.</span>
        P(i) = EOSmie(E_int(i), B_rho, B_C, B_S, Rho(i), B_gamma);

        <span class="comment">%%%Derivadas espaciales de las Velocidades</span>
        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = <span class="keyword">...</span>
            Velgradesp(Rho, M, V1, V2, dkernx{i}, dkerny{i},<span class="keyword">...</span>
            Nearpart{i},i);

        <span class="comment">%%%Deformacion unitaria</span>
        [eps11(i), eps12(i), eps21(i), eps22(i)] = <span class="keyword">...</span>
            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));

        <span class="comment">%%%Derivadas de Esfuerzos Cortantes</span>
        [dTau11(i), dTau12(i), dTau21(i), dTau22(i)] = <span class="keyword">...</span>
            devstresshooke(dv1dx2(i), dv2dx1(i),<span class="keyword">...</span>
                Tau11(i), Tau12(i), Tau21(i), Tau22(i),<span class="keyword">...</span>
                eps11(i), eps21(i), eps22(i), B_G);

        <span class="comment">%%%Calcular Esfuerzos</span>
        <span class="comment">% No se puede hacer opearacion vectorizada porque el Tau</span>
        <span class="comment">% se corrgie con criterio de Von Mises</span>
        Tau11(i) = Tau11(i) + dTau11(i)*dt;
        Tau12(i) = Tau12(i) + dTau12(i)*dt;
        Tau21(i) = Tau21(i) + dTau21(i)*dt;
        Tau22(i) = Tau22(i) + dTau22(i)*dt;
</pre><h2>Criterio de falla de Von Mises<a name="21"></a></h2><pre class="codeinput">        J = Tau11(i)^2 + 2*Tau12(i)*Tau21(i) + Tau22(i)^2;
        f = sqrt(2*B_Y0/3);
        <span class="keyword">if</span> J &gt; B_Y0*3/2
            scalar = f/sqrt(J);
            Tau11(i) = Tau11(i)*scalar;
            Tau12(i) = Tau12(i)*scalar;
            Tau21(i) = Tau21(i)*scalar;
            Tau22(i) = Tau22(i)*scalar;
        <span class="keyword">end</span>

        <span class="comment">%%%Damage</span>
        <span class="comment">% Damage NO aplica para las particulas del bullet</span>

        <span class="comment">%%%Ecuacion de la continuidad</span>
        <span class="comment">% Calcular la derivada de la densidad para una particula</span>
        dRho(i) = derivadarho(M, V1, V2, <span class="keyword">...</span>
            dkernx{i}, dkerny{i}, Nearpart{i}, i);
    <span class="keyword">end</span>

    <span class="comment">%%%Avanzar la densidad en el tiempo</span>
    Rho(T_np+1:N_part) = Rho(T_np+1:N_part) + dRho(T_np+1:N_part)*dt;

    <span class="keyword">for</span> i = T_np+1:N_part
       <span class="comment">%%%Conservacion de Momentum</span>
       [dV1(i),dV2(i)] = Momentumeq2d(Tau11, Tau12, Tau21, Tau22, P, Rho,<span class="keyword">...</span>
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,<span class="keyword">...</span>
           h, V1, V2);


       <span class="comment">%%%Conservacion de la Energia</span>
       dE_int(i) = Deint(Tau11(i), Tau12(i), Tau21(i), Tau22(i), P, Rho,<span class="keyword">...</span>
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,<span class="keyword">...</span>
           h, V1, V2, eps11(i), eps12(i), eps21(i), eps22(i));
    <span class="keyword">end</span>

    <span class="comment">%%%Avanzar la velocidad</span>
    V1(T_np+1:N_part) = V1(T_np+1:N_part) + dV1(T_np+1:N_part)*dt;
    V2(T_np+1:N_part) = V2(T_np+1:N_part) + dV2(T_np+1:N_part)*dt;
    E_int(T_np+1:N_part) = E_int(T_np+1:N_part) + dE_int(T_np+1:N_part)*dt;

    <span class="comment">%%%Correcciones</span>
    <span class="keyword">for</span> i = T_np+1:N_part
        <span class="comment">%%%Velocidad del sonido</span>
        cs(i) = Miespeedofsound(E_int(i), B_rho, B_C, B_S,Rho(i), B_gamma);

        <span class="comment">%%%XSPH</span>
        [V1(i),V2(i)] = XSPH(Nearpart{i}, M, Rho, V1, V2, kern{i}, i);
    <span class="keyword">end</span>
    Particles(T_np+1:N_part,:) = Particles(T_np+1:N_part,:) + <span class="keyword">...</span>
        [V1(T_np+1:N_part), V2(T_np+1:N_part)]*dt;
    Particles = real(Particles);
</pre><h2>Graficas<a name="22"></a></h2><pre class="codeinput">    figure(1)
    <span class="keyword">if</span> mod(ti-1,20)==0
        figure(1)
        p = Nearpart{1300};

        <span class="comment">%plot(Particles(:,1), Particles(:,2),'.b')</span>
        subplot(2,1,1)
        scatter(Particles(:,1),Particles(:,2),10,V1,<span class="string">'filled'</span>)
        hold <span class="string">on</span>
        scatter(Particles(p,1),Particles(p,2),30,<span class="string">'black'</span>)

        title(<span class="string">'V1'</span>)
        caxis([-V_1/2,V_1])
        colorbar()
        xlim([-6e-3,2e-3])
        ylim([-4e-3,4e-3])
        <span class="comment">%axis('equal')</span>
        drawnow

        subplot(2,1,2)
        scatter(Particles(:,1),Particles(:,2),10,P,<span class="string">'filled'</span>)
        title(<span class="string">'Presion'</span>)
        caxis([0,3e6])
        colorbar()
        xlim([-6e-3,2e-3])
        ylim([-4e-3,4e-3])
        <span class="comment">%axis('equal')</span>
        drawnow
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Factorial_k10_02.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_03.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_04.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_05.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_06.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_07.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_08.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_09.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_10.png" alt=""> <img vspace="5" hspace="5" src="Factorial_k10_11.png" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">Numero de Pasos = 188
</pre><h2>Comentarios JC<a name="24"></a></h2><p>Situaciones por corregir: # Generacion de numero complejos Se estan generando coordenadas complejas en el arreglo <i>Particles</i>, pro el momento lo soluciono tomando solo la parte real de <i>Particles</i>. Tambien se estan generando complejos en <i>dE_int</i> y otras derivadas # Propiedades de Materiales Se esta trabajndo unicamente con las propiedades del basalto. Falta consultar propiedades para un material comun en balas</p><pre class="codeinput"><span class="comment">%}</span>
<span class="comment">%}</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Bullet_Impact
% Simulacion de impacto de taylor.
% Se define barrera con particulas virtuales que ejercen fuerza de
% repulsion sobre particulas reales
%
% v_s = 70 m/s
%

clear all; clc; close all;
%% Definir Geometria del Objetivo
% Todas las unidades son dadas en el sistema internacional de unidades
%
% Se define las posiciones de las particulas que conforman el objetivo
%
% Geometria del objetivo
T_dy = 0.5e-4; %    Separacion entre particulas
T_dx = T_dy*1;   %     
k = 10.0;   %    Constante para expandir radio de soporte
h = k*T_dx;  %    Radio de soporte

T_width = 0.0001;               % Ancho del objetivo
T_height = 0.005;              % Alto del objetivo
T_x = linspace(-T_width,T_width,3);
T_y = -T_height : T_dy : T_height;
[X,Y] = meshgrid(T_x, T_y);     % Matriz con la malla de las posiciones x,y para las particulas
Target = [X(:),Y(:)];           %   | x_1 , y_1 |   En esta matriz organiza    
                                %   | .   , .   |   todas las posiciones de las
                                %   | x_n , y_n |   particulas.
                                %   [T_np x 2]

T_np = size(Target,1);          % Numero de particulas en el objetivo

%% Asignacion de defectos puntuales en Objetivo
% Constantes para asginacion de fallas en basalto
m = 3;
k = 7;
T_V = T_dx*T_dy*1;    % Volumen infinitesimal

Nflaws = T_np*log(T_np);        % Numero de defectos puntuales a asignar
Nflaws = round(Nflaws);         
assign_flaws = randi(T_np,Nflaws,1,'uint32'); % [Nflaws x 1]
                                %  Nflaws numeros aleatorios entre 1 y T_np
[Flaws{1:T_np,1}] = deal([]);   %  Flaws [cell array] {T_np x 1}
                                %  Cell array con ''T_np matrices vacias
                                %  Cell de pre-alocacion para fallas
                                
for i = 1:Nflaws
    Flaws{assign_flaws(i),1}(size(Flaws{assign_flaws(i),1})+1) = ...
        (i/(k*T_V))^(1/m);
end
%%
% *assign_flaws*   [Nflaws x 1]    vector que contiene _Nflaws_ posiciones de
% las fallas a generar. Las posiciones estan dadas como numeros enteros en
% relacion al numero de cada particula.
% 
% *Flaws*       cell{T_np x 1}    Contiene _T_np_ matrices vacias que
% identifican las fallas para cada particula. *Flaws* se va llenando 
% de forma aleatoria con las posiciones que indica _assing_flaws_. La
% primera vez que se pasa por una amtriz de Flaws, le asigna el numero
% (i/(k*V))^(1/m) formando una matriz 1x1. La segunda vez que se pasa por
% la misma matriz, aumenta la dimension de la matriz en una sola direccion
% para asignar otro numero. Asi, si semi-aleatoriamente, el numero _k_
% aparecio _n_ veces de _assign_flaws_, la celda _Flaws_ en su posicion _k_
% debe contener una matriz nx1 con numeros asignados. Los numeros asignados
% corresponden a las deformaciones de activacion para los defectos
% puntuales de cada particula

%% Constantes del Material Objetivo
% Todas las unidades estan en el sistema internacional de unidades
T_rho = 7850;               %Densidad volumetrica del objetivo
T_m0 = T_dx*T_dy*T_rho;     %Masa de una particula

%Parametros de Huggoniot
T_ss = 4699;
T_C = 3630;
T_S = 1800;

%Parametros de XSPH
T_gamma = 1.81;
T_alpha = 0.5;
T_beta = 0.5;
T_eta = 0.01;
T_eps = 0.5;

%Parametros de Elasticidad
T_G = 8e10;         % Modulo de cortante
T_Y0 = 6e20;         % Esfuerzo de fluencia % Cambio de e8 a e20
T_E = T_ss^2*T_rho;   % Modulo de Young

%% Definir Geometria del Proyectil
% Se definen las posiciones de las particulas que conforman el proyectil.
%
% Se asume que el proyectil se mueve en la direccion horizontal.
%
% Proyectil rectangular
%
s_x = h/5;             % Separacion en x entre proyectil y objetivo
B_width = 0.003;    % Ancho del proyectil
B_height = 0.002;  % Alto del proyectil
B_x0 = min(Target(:,1))-B_width-s_x;
B_y0 = mean(Target(:,2)); % Posiciones de referencia para el objetivo
B_dx = 1e-4;            % Separacion entre particulas del proyectil
B_dy = 2e-4;

B_x = [-B_width : B_dx : B_width] + B_x0;
B_y = [-B_height : B_dy : B_height] + B_y0;
[X,Y] = meshgrid(B_x,B_y);  % Matrices con la malla para las posiciones 
                            % de la particulas en el proyectil
Bullet = [X(:),Y(:)];       % Posicion de las particulas en el pryectil
B_np = size(Bullet,1);      % Numero de particulas en el proyectil
%}
%%
% Proyectil redondo
%{
s_x = h/5;         % separacion en x entre proyectil y objetivo
B_dr = 1e-4;        % Variacion en el radio del proyectil
B_rmax = 0.002;  % Radio maximo del proyectil
B_r = B_dr:B_dr:B_rmax; % Valores del radio en el proyectil
n_theta = 18*2;         % Numero de puntos a considerar en el angulo
B_theta = linspace(0,2*pi,n_theta); % Valores del angulo
B_cx = min(Target(:,1)) - B_rmax - s_x; % Centro del proyectil
B_cy = mean(Target(:,2));
B_np = length(B_r)*length(B_theta); %Numero de particulas en el proyectil
Bullet = zeros(B_np,2); % Posiciones x,y de las particulas en el proyectil
for i = 1:length(B_r)
    for j = 1:length(B_theta)
        Bullet((i-1)*n_theta+j,:) = [B_r(i)*cos(B_theta(j))+B_cx,...
            B_r(i)*sin(B_theta(j))+B_cy];
    end
end
%}
%
%% Constantes del Material Proyectil
% Por el momento estas magnitudes corresponden a las mismas del objetivo
%
% **Consultar Propiedades para algun metal y reemplazaralas**
B_rho = 7850;               %Densidad volumetrica del objetivo
%B_m0 = pi*B_dr^2*B_rho;     %Masa de una particula -Cilindrico
B_m0 = B_dx*B_dy*B_rho;
%B_V = pi*B_dr^2*1; % Circular
B_V = B_dx*B_dy;
%Parametros de Huggoniot
B_ss = 4699;
B_C = 3630;
B_S = 1800;

%Parametros de XSPH
B_gamma = 1.81;
B_alpha = 0.5;
B_beta = 0.5;
B_eta = 0.01;
B_eps = 0.5;

%Parametros de Elasticidad
B_G = 8e10;             % Modulo de cortante
B_Y0 = 6e8;             % Esfuerzo de fluencia
B_E = T_ss^2*T_rho;     % Modulo de Young


%% Alocacion de Matrices Requeridas para calculos
N_part = T_np + B_np; % Numero total de particulas

Particles = [Target;Bullet];    % Posiciones de particulas
V1 = zeros(N_part,1);   % Velocidad en la direccion 1
V2 = zeros(N_part,1);   
dV1 = zeros(N_part,1);  % Derivada total de V1
dV2 = zeros(N_part,1);  
    dv1dx1 = zeros(N_part,1); 
    dv1dx2 = zeros(N_part,1);   % Derivada de V1 en direccion 2
    dv2dx1 = zeros(N_part,1);
    dv2dx2 = zeros(N_part,1);
P = zeros(N_part,1);    % Presion Hidrostatica

Tau11 = zeros(N_part,1);
Tau12 = zeros(N_part,1);    % Esfuerzos en cara 1 con direccion 2
Tau21 = zeros(N_part,1);
Tau22 = zeros(N_part,1);
    dTau11 = zeros(N_part,1);
    dTau12 = zeros(N_part,1); % Derivada de esfuerzos en cara 1 con dir 2
    dTau21 = zeros(N_part,1);
    dTau22 = zeros(N_part,1);
    
eps11 = zeros(N_part,1);
eps12 = zeros(N_part,1);    % Deformacion unitaria en cara 1 con dir 2
eps21 = zeros(N_part,1);
eps22 = zeros(N_part,1);

E_int = zeros(N_part,1);        % Energia Interna
    dE_int = zeros(N_part,1);   % Derivada de Energia Interna

%% Asignacion Selectiva de Propiedades
% Hay que revisar esta matrices porque las propiedades deben inicializarse
% de acuerdo al _tipo de las particulas_, es decir que se deben asignar
% propiedades diferentes a las particulas del *objetivo* y a las particulas
% del *proyectil*
M = zeros(N_part,1);        % Masa de las particulas
M(1:T_np) = ones(T_np,1)*T_V*T_rho; % Particulas del objetivo
M(T_np+1:end) = ones(B_np,1)*B_V*B_rho; % Particulas del proyectil

cs = zeros(N_part,1);       % Velocidad del sonido
cs(1:T_np) = ones(T_np,1)*T_ss;
cs(T_np+1:end) = ones(B_np,1)*B_ss;

Rho = zeros(N_part,1);      % Densidad
Rho(1:T_np) = ones(T_np,1)*T_rho; 
Rho(T_np+1:end) = ones(B_np,1)*B_rho; 
    
    dRho = zeros(N_part,1); % Derivada de la densidad
    
D = zeros(N_part,1);        % Damage

%% Asignacion de condiciones iniciales
V_1 = 70;
%rr = randint(50,1,[1,T_np]);
V1(T_np+1:N_part) = V_1; % Velocidad inicial del Bullet
%
%% Representacion de condiciones iniciales
figure(1)
plot(Target(:,1),Target(:,2),Bullet(:,1),Bullet(:,2),...
    'Marker', '.', 'LineStyle','none')
title('Configuracion Inicial')
xlabel('X'); ylabel('Y'); axis('equal')
%% Inicio de Simulacion
%
display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~');
display('   Inicio de la simulacion')
display('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')

t = 0;  %Tiempo Inicial
dt = max(h/cs)/2; % Paso de tiempo
                % El paso de tiempo se define de esta forma para que la
                % simulacion sea capaz de detectar el fenomeno mas rapido
                % al que sea sensible el problema
                % La definicion correcta es 
                % min(h/cs)
                % pero lo ejecuta con max para que dt sea diferente de 0 y
                % la simulacion no sea muy larga
tf = 0.5e-6*20; % Tiempo final
steps = round(tf/dt);  % Numero de pasos

%%
% Matrices para guardar informacion de la simulacion
n_m = round(20/100*steps);     % Numero de datos para muestreo

Coordenadas = zeros(N_part,n_m);
Velocidad1 = zeros(N_part,n_m);
Velocidad2 = zeros(N_part,n_m);
Presion = zeros(N_part,n_m);
Esfuerzos11 = zeros(N_part,n_m);
Esfuerzos12 = zeros(N_part,n_m);
Esfuerzos21 = zeros(N_part,n_m);
Esfuerzos22 = zeros(N_part,n_m);
Densidad = zeros(N_part,n_m);

%% Repulsion en la frontera
n1 = 12;
n2 = 4;
D_repulsion  = 5;
r0_repulsion = 2*h;
%% Recorrido principal en el tiempo
fprintf('Numero de Pasos = %d\n',steps)
for ti = 1:steps
    %fprintf('%d..',ti);
    
    
    %% Busqueda de Vecinos
    %
    % *Nearpart*        cell {N_part x 1}:
    % En el compartimiento _i_ de *Nearpart*, se encuentra un vector [1 x n] 
    % que contiene los indices de las n particulas vecinas a la particula
    % de identidad _i_.
    %
    % *Dist*        cell {Npart x 1}:
    % En el compartimiento _i_ de *Dist*, se encuentra un vector [1 x n] que 
    % contiene la distancia _r_n_ a la que se encuentra cada una de las
    % _n_ particulas vecinas de la particula _i_.
    [Nearpart,Dist] = rangesearch(Particles,Particles,h);
    
    %
    % Se genera el _cell_ para el kernel *kern*. Este cell tiene las mismas
    % dimensiones que el cell _Dist_, con la diferencia que todos los
    % valores son _0_
    kern = cellfun(@(x) x*0, Dist, 'un', 0);
        dkernx = kern;  %Inicializar en 0 las derivadas del kernel
        dkerny = kern;
    
    % Usando las funciones kern1, dkernx1 y dkerny1 se calcula el kernel
    % y las derivadas del kernel x-y evaluadas en las particulas vecinas 
    % de cada una de las particulas del dominio.
    
    %% Recorrido en las particulas del Target
    for i = 1:T_np
        kern{i} = kern1(Dist{i},h);
        dkernx{i} = dkernx1(Dist{i}, h, Particles, Nearpart{i}, i);
        dkerny{i} = dkerny1(Dist{i}, h, Particles, Nearpart{i}, i);
        
        %%%Calcular Presion hidrostatica con ecuacion de Mie-Gruniensen
        %
        %   Esta parte se puede hacer mas eficiente. De esta forma es
        %   ineficiente porque realiza validacion y asignacion para cada
        %   particula. Creo que si hago recorridos independientes para las
        %   particulas del objetivo y del proyectil, solo hago dos
        %   asignaciones y ninguna verificacion.
        P(i) = EOSmie(E_int(i), T_rho, T_C, T_S, Rho(i), T_gamma);
        
        %%%Derivadas espaciales de las Velocidades
        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = ...
            Velgradesp(Rho, M, V1, V2, dkernx{i}, dkerny{i},...
            Nearpart{i},i);
        
        %%%Deformacion unitaria
        [eps11(i), eps12(i), eps21(i), eps22(i)] = ...
            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));
        
        %%%Derivadas de Esfuerzos Cortantes
        [dTau11(i), dTau12(i), dTau21(i), dTau22(i)] = ...
            devstresshooke(dv1dx2(i), dv2dx1(i),...
                Tau11(i), Tau12(i), Tau21(i), Tau22(i),...
                eps11(i), eps21(i), eps22(i), T_G);

        %%%Calcular Esfuerzos
        % No se puede hacer opearacion vectorizada porque el Tau
        % se corrgie con criterio de Von Mises 
        Tau11(i) = Tau11(i) + dTau11(i)*dt;
        Tau12(i) = Tau12(i) + dTau12(i)*dt;
        Tau21(i) = Tau21(i) + dTau21(i)*dt;
        Tau22(i) = Tau22(i) + dTau22(i)*dt;
        
        %%%Criterio de falla de Von Mises
        J = Tau11(i)^2 + 2*Tau12(i)*Tau21(i) + Tau22(i)^2;
        f = sqrt(2*T_Y0/3);
        if J > T_Y0*3/2
            scalar = f/sqrt(J);
            Tau11(i) = Tau11(i)*scalar;
            Tau12(i) = Tau12(i)*scalar;
            Tau21(i) = Tau21(i)*scalar;
            Tau22(i) = Tau22(i)*scalar;
        end
        
        %%%Damage
        % Damage solo aplica para las particulas del Target
        % Modificacion importante respecto al codigo de Daniel:
        % 
        % Cambio *if ei > length(Flaws{i}(j))* por 
        % *if ei > Flaws{i}(j)* Hago esta modificacion porque lo que se
        % necesita es contar cuantos defectos puntuales se activan
        %
        %Energia de activacion
        ei = J/((1-D(i))*T_E);
        
        % Recorrido en los defectos puntuales
        for j = 1:length(Flaws{i})
            count = 0;
            % Contar cuantos defectos se activan
            if ei > Flaws{i}(j)
                count = count + 1;
            end
        end
        
        % Damage depende del numero de fallas activas
        % Revisar refrencia de Damage, creo que este procedimiento no es
        % del todo correcto porque el Damage = 1 se alcanza solo cuando
        % todas los defectos estan activos. Entonces dberia ser algo de la
        % forma count/length(Flaws{i})
        %
        dD = Damageevol(Rho(i), M(i), cs(i)) * count;
        D(i) = dD^2*dt;
        
        % Escalar esfuerzos del material con el Damage
        Tau11(i) = Tau11(i)*(1-D(i));
        Tau12(i) = Tau12(i)*(1-D(i));
        Tau21(i) = Tau21(i)*(1-D(i));
        Tau22(i) = Tau22(i)*(1-D(i));
        

        %%%Ecuacion de la continuidad
        % Calcular la derivada de la densidad para una particula
        dRho(i) = derivadarho(M, V1, V2, ...
            dkernx{i}, dkerny{i}, Nearpart{i}, i);
    end
    
    %%%Avanzar la densidad en el tiempo
    Rho(1:T_np) = Rho(1:T_np) + dRho(1:T_np)*dt;
    
    for i = 1:T_np
       %%%Conservacion de Momentum
       [dV1(i),dV2(i)] = Momentumeq2d(Tau11, Tau12, Tau21, Tau22, P, Rho,...
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,...
           h, V1, V2);
       
       %%%%Conservacion de la Energia
       dE_int(i) = Deint(Tau11(i), Tau12(i), Tau21(i), Tau22(i), P, Rho,...
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,...
           h, V1, V2, eps11(i), eps12(i), eps21(i), eps22(i));
    end
    
    for i = 1:T_np
    %%Repulsion
       [ddV1,ddV2] = Repulsion_frontera(Particles, i, Nearpart, Dist,...
           D_repulsion, r0_repulsion, n1, n2, M);
       dV1 = dV1 + ddV1;
       dV2 = dV2 + ddV2;
       %[dV1, dV2] = [dV1, dV2] + [ddV1,ddV2];
    end
    
    %%%Avanzar la velocidad
    V1(1:T_np) = V1(1:T_np) + dV1(1:T_np)*dt;
    V2(1:T_np) = V2(1:T_np) + dV2(1:T_np)*dt;
    E_int(1:T_np) = E_int(1:T_np) + dE_int(1:T_np)*dt;
    
    %%%Correcciones
    for i = 1:T_np
        %%%Velocidad del sonido
        cs(i) = Miespeedofsound(E_int(i), T_rho, T_C, T_S,Rho(i), T_gamma);
        
        %%%XSPH
        [V1(i),V2(i)] = XSPH(Nearpart{i}, M, Rho, V1, V2, kern{i}, i);
    end
    
    % No muevo las particlas del target
    %Particles(1:T_np,:) = Particles(1:T_np,:) + ...
    %    [V1(1:T_np), V2(1:T_np)]*dt;
    
    % Hasta aca se tiene configurado completamente la simulacion para
    % las particulas del target
    
    %% Recorrido en las particulas del Bullet
    for i = T_np+1:N_part
        kern{i} = kern1(Dist{i},h);
        dkernx{i} = dkernx1(Dist{i}, h, Particles, Nearpart{i}, i);
        dkerny{i} = dkerny1(Dist{i}, h, Particles, Nearpart{i}, i);
        
        %%%Calcular Presion hidrostatica con ecuacion de Mie-Gruniensen
        %
        %   Esta parte se puede hacer mas eficiente. De esta forma es
        %   ineficiente porque realiza validacion y asignacion para cada
        %   particula. Creo que si hago recorridos independientes para las
        %   particulas del objetivo y del proyectil, solo hago dos
        %   asignaciones y ninguna verificacion.
        P(i) = EOSmie(E_int(i), B_rho, B_C, B_S, Rho(i), B_gamma);
        
        %%%Derivadas espaciales de las Velocidades
        [dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i)] = ...
            Velgradesp(Rho, M, V1, V2, dkernx{i}, dkerny{i},...
            Nearpart{i},i);
        
        %%%Deformacion unitaria
        [eps11(i), eps12(i), eps21(i), eps22(i)] = ...
            deform(dv1dx1(i), dv1dx2(i), dv2dx1(i), dv2dx2(i));
        
        %%%Derivadas de Esfuerzos Cortantes
        [dTau11(i), dTau12(i), dTau21(i), dTau22(i)] = ...
            devstresshooke(dv1dx2(i), dv2dx1(i),...
                Tau11(i), Tau12(i), Tau21(i), Tau22(i),...
                eps11(i), eps21(i), eps22(i), B_G);

        %%%Calcular Esfuerzos
        % No se puede hacer opearacion vectorizada porque el Tau
        % se corrgie con criterio de Von Mises 
        Tau11(i) = Tau11(i) + dTau11(i)*dt;
        Tau12(i) = Tau12(i) + dTau12(i)*dt;
        Tau21(i) = Tau21(i) + dTau21(i)*dt;
        Tau22(i) = Tau22(i) + dTau22(i)*dt;
        
        %%% Criterio de falla de Von Mises
        J = Tau11(i)^2 + 2*Tau12(i)*Tau21(i) + Tau22(i)^2;
        f = sqrt(2*B_Y0/3);
        if J > B_Y0*3/2
            scalar = f/sqrt(J);
            Tau11(i) = Tau11(i)*scalar;
            Tau12(i) = Tau12(i)*scalar;
            Tau21(i) = Tau21(i)*scalar;
            Tau22(i) = Tau22(i)*scalar;
        end
        
        %%%Damage
        % Damage NO aplica para las particulas del bullet
                 
        %%%Ecuacion de la continuidad
        % Calcular la derivada de la densidad para una particula
        dRho(i) = derivadarho(M, V1, V2, ...
            dkernx{i}, dkerny{i}, Nearpart{i}, i);
    end
    
    %%%Avanzar la densidad en el tiempo
    Rho(T_np+1:N_part) = Rho(T_np+1:N_part) + dRho(T_np+1:N_part)*dt;
    
    for i = T_np+1:N_part
       %%%Conservacion de Momentum
       [dV1(i),dV2(i)] = Momentumeq2d(Tau11, Tau12, Tau21, Tau22, P, Rho,...
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,...
           h, V1, V2);
       
             
       %%%Conservacion de la Energia
       dE_int(i) = Deint(Tau11(i), Tau12(i), Tau21(i), Tau22(i), P, Rho,...
           dkernx{i}, dkerny{i}, M, Nearpart{i}, i, cs, Dist{i}, Particles,...
           h, V1, V2, eps11(i), eps12(i), eps21(i), eps22(i));
    end 
    
    %%%Avanzar la velocidad
    V1(T_np+1:N_part) = V1(T_np+1:N_part) + dV1(T_np+1:N_part)*dt;
    V2(T_np+1:N_part) = V2(T_np+1:N_part) + dV2(T_np+1:N_part)*dt;
    E_int(T_np+1:N_part) = E_int(T_np+1:N_part) + dE_int(T_np+1:N_part)*dt;
    
    %%%Correcciones
    for i = T_np+1:N_part
        %%%Velocidad del sonido
        cs(i) = Miespeedofsound(E_int(i), B_rho, B_C, B_S,Rho(i), B_gamma);
        
        %%%XSPH
        [V1(i),V2(i)] = XSPH(Nearpart{i}, M, Rho, V1, V2, kern{i}, i);
    end
    Particles(T_np+1:N_part,:) = Particles(T_np+1:N_part,:) + ...
        [V1(T_np+1:N_part), V2(T_np+1:N_part)]*dt;
    Particles = real(Particles);
    
    
    %% Graficas
    
    figure(1)
    if mod(ti-1,20)==0
        figure(1)
        p = Nearpart{1300};
        
        %plot(Particles(:,1), Particles(:,2),'.b')
        subplot(2,1,1)
        scatter(Particles(:,1),Particles(:,2),10,V1,'filled')
        hold on
        scatter(Particles(p,1),Particles(p,2),30,'black')
        
        title('V1')
        caxis([-V_1/2,V_1])
        colorbar()
        xlim([-6e-3,2e-3])
        ylim([-4e-3,4e-3])
        %axis('equal')
        drawnow
        
        subplot(2,1,2)
        scatter(Particles(:,1),Particles(:,2),10,P,'filled')
        title('Presion')
        caxis([0,3e6])
        colorbar()
        xlim([-6e-3,2e-3])
        ylim([-4e-3,4e-3])
        %axis('equal')
        drawnow
    end
    
end

%% Comentarios JC
% 
% Situaciones por corregir:
% # Generacion de numero complejos
% Se estan generando coordenadas complejas en el arreglo _Particles_, pro
% el momento lo soluciono tomando solo la parte real de _Particles_.
% Tambien se estan generando complejos en _dE_int_ y otras derivadas
% # Propiedades de Materiales
% Se esta trabajndo unicamente con las propiedades del basalto. Falta
% consultar propiedades para un material comun en balas
%
%
%}
%}
##### SOURCE END #####
--></body></html>